<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel Art Converter (Web)</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#12161a; --muted:#8b98a5; --text:#e7edf3; --acc:#5dd3ff; --acc2:#8ef29b;
      --border:#22303c; --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:radial-gradient(1200px 600px at 20% -10%, #14202b, transparent), var(--bg);
      color:var(--text);
    }
    header{padding:24px 16px; text-align:center}
    header h1{margin:0 0 8px; font-size:clamp(20px,3vw,32px)}
    header p{margin:0; color:var(--muted)}

    .app{max-width:1200px; margin:0 auto; padding:16px; display:grid; grid-template-columns: 1.1fr 1fr; gap:16px}
    @media (max-width: 980px){.app{grid-template-columns:1fr}}

    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.0)); border:1px solid var(--border); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,0.25); overflow:hidden}
    .card h2{margin:0; padding:14px 16px; border-bottom:1px solid var(--border); font-size:18px; background:rgba(255,255,255,0.02)}
    .card .content{padding:14px 16px}

    .controls{display:grid; gap:12px}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    label{font-size:13px; color:var(--muted)}
    input[type="number"], input[type="range"], input[type="text"], select{background:#0f1419; color:var(--text); border:1px solid var(--border); padding:8px 10px; border-radius:10px}
    input[type="file"]{accent-color:var(--acc)}
    input[type="color"]{border:1px solid var(--border); background:#0f1419; height:36px; width:36px; border-radius:10px; padding:0}
    .btn{background:linear-gradient(180deg, #142433, #0f1b26); color:#dff7ff; border:1px solid #1d3344; padding:10px 14px; border-radius:12px; cursor:pointer; transition:transform .06s ease, box-shadow .2s ease}
    .btn:hover{transform:translateY(-1px); box-shadow:0 8px 18px rgba(93,211,255,.08)}
    .btn.secondary{background:#141a20; border-color:#243240; color:#cfe8ff}
    .btn.green{background:linear-gradient(180deg,#10341f,#0b2717); border-color:#1b4d2a}
    .btn.danger{background:linear-gradient(180deg,#381517,#2a0f10); border-color:#642027; color:#ffdfe4}

    .grid{display:grid; grid-template-columns: repeat(auto-fill, minmax(42px, 1fr)); gap:8px}

    .palette-list{display:flex; flex-wrap:wrap; gap:10px}
    .chip{display:flex; align-items:center; gap:8px; background:#0e1419; border:1px solid var(--border); padding:6px; border-radius:12px}
    .chip input[type="text"]{width:90px}
    .chip .remove{border:none; background:transparent; color:var(--danger); cursor:pointer; font-size:18px; line-height:1}

    .canvases{display:grid; gap:12px}
    canvas{width:100%; aspect-ratio:1/1; image-rendering: pixelated; background:#0a0f13; border:1px solid var(--border); border-radius:12px}

    .muted{color:var(--muted)}
    .divider{height:1px; background:var(--border); margin:10px 0}
    .note{font-size:12px; color:var(--muted)}
    footer{max-width:1200px; margin:24px auto; padding:0 16px; color:var(--muted); font-size:12px}
  </style>
</head>
<body>
  <header>
    <h1>ðŸ§Š Pixel Art Converter Piggychanaâ€” wersja web</h1>
    <p>ZaÅ‚aduj obraz, ustaw wymiary pikselowe, edytuj paletÄ™, konwertuj i pobierz wynik jako PNG.</p>
  </header>

  <main class="app">
    <!-- LEFT: Controls -->
    <section class="card">
      <h2>Ustawienia & Paleta</h2>
      <div class="content controls">

        <div class="row">
          <label>Obraz:</label>
          <input id="fileInput" type="file" accept="image/*" />
          <button class="btn secondary" id="resetBtn">Reset</button>
        </div>

        <div class="row">
          <label for="w">SzerokoÅ›Ä‡ (px):</label>
          <input id="w" type="number" min="1" value="32" style="width:90px" />
          <label for="h">WysokoÅ›Ä‡ (px):</label>
          <input id="h" type="number" min="1" value="32" style="width:90px" />
          <label class="row" style="gap:6px">
            <input id="lockAspect" type="checkbox" checked />
            Zachowaj proporcje
          </label>
        </div>

        <div class="row">
          <label for="exportScale">Skala eksportu:</label>
          <input id="exportScale" type="number" min="1" value="20" style="width:90px" />
          <span class="note">(powiÄ™kszenie koÅ„cowego sprite'a)</span>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button class="btn" id="paletteFromImage">Paleta ze zdjÄ™cia</button>
          <label>IloÅ›Ä‡ kolorÃ³w:</label>
          <input id="paletteSize" type="number" min="2" max="64" value="12" style="width:90px" />
        </div>

        <div>
          <label>Paleta (edytowalna):</label>
          <div id="paletteList" class="palette-list"></div>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="addColor">Dodaj kolor</button>
            <button class="btn danger" id="clearPalette">WyczyÅ›Ä‡ paletÄ™</button>
            <button class="btn secondary" id="loadDefaultPalette">ZaÅ‚aduj domyÅ›lnÄ… paletÄ™</button>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button class="btn green" id="convertBtn">Konwertuj â†’</button>
          <button class="btn" id="downloadBtn">Pobierz PNG</button>
        </div>

      </div>
    </section>

    <!-- RIGHT: Preview -->
    <section class="card">
      <h2>PodglÄ…d</h2>
      <div class="content">
        <div class="canvases">
          <div class="row" style="justify-content:space-between">
            <span class="muted">OryginaÅ‚</span>
            <span class="muted">Wynik (pixel art)</span>
          </div>
          <div class="row" style="gap:12px">
            <canvas id="inputCanvas"></canvas>
            <canvas id="outputCanvas"></canvas>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    WskazÃ³wka: moÅ¼esz przeciÄ…gnÄ…Ä‡ i upuÅ›ciÄ‡ obraz na stronÄ™. Wszystko dzieje siÄ™ lokalnie w przeglÄ…darce.
  </footer>

  <script>
    // ====== Utils ======
    const clamp = (n, min, max)=> Math.max(min, Math.min(max, n));
    const hexToRgb = (hex)=>{
      hex = hex.replace('#','');
      if (hex.length===3){ hex = hex.split('').map(x=>x+x).join(''); }
      const int = parseInt(hex,16);
      return [ (int>>16)&255, (int>>8)&255, int&255 ];
    };
    const rgbToHex = ([r,g,b])=> '#' + [r,g,b].map(v=> v.toString(16).padStart(2,'0')).join('');
    const dist2 = (a,b)=>{ let d0=a[0]-b[0], d1=a[1]-b[1], d2=a[2]-b[2]; return d0*d0+d1*d1+d2*d2; };

    // Default palette (from your list)
    const DEFAULT_PALETTE_HEX = [
      '#000000','#3c3c3c','#787878','#d2d2d2','#ffffff','#600018','#ed1c24','#ff7f27','#f6aa09','#f9dd3b',
      '#fffabc','#0eb968','#13e67b','#0c816e','#13e1be','#28509e','#4093e4','#60f7f2','#6b50f6','#99b1fb',
      '#780c99','#aa38b9','#e09ff9','#cb007a','#d0418b','#f38da9','#684634','#95682a','#f8b277'
    ];

    // DOM refs
    const fileInput = document.getElementById('fileInput');
    const inputCanvas = document.getElementById('inputCanvas');
    const outputCanvas = document.getElementById('outputCanvas');
    const wInput = document.getElementById('w');
    const hInput = document.getElementById('h');
    const lockAspect = document.getElementById('lockAspect');
    const exportScaleInput = document.getElementById('exportScale');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn = document.getElementById('resetBtn');

    const paletteList = document.getElementById('paletteList');
    const addColorBtn = document.getElementById('addColor');
    const clearPaletteBtn = document.getElementById('clearPalette');
    const loadDefaultPaletteBtn = document.getElementById('loadDefaultPalette');
    const paletteFromImageBtn = document.getElementById('paletteFromImage');
    const paletteSizeInput = document.getElementById('paletteSize');

    let originalImage = null; // HTMLImageElement
    let aspect = 1;
    let palette = DEFAULT_PALETTE_HEX.map(hexToRgb);

    // Canvas helpers
    const inCtx = inputCanvas.getContext('2d');
    const outCtx = outputCanvas.getContext('2d');

    function fitCanvasToImage(canvas, img){
      // Keep square visual but correct internal ratio for crispness
      const maxSide = 512; // visual size; CSS scales to 100%
      const ratio = img.width / img.height;
      let w = maxSide, h = maxSide;
      if (ratio>1){ h = Math.round(maxSide/ratio); } else { w = Math.round(maxSide*ratio); }
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0,w,h);
    }

    function drawImageOnCanvas(canvas, img){
      fitCanvasToImage(canvas, img);
    }

    function renderPaletteUI(){
      paletteList.innerHTML = '';
      palette.forEach((rgb, idx)=>{
        const wrap = document.createElement('div');
        wrap.className = 'chip';
        const color = document.createElement('input');
        color.type = 'color';
        color.value = rgbToHex(rgb);
        color.addEventListener('input', ()=>{ palette[idx] = hexToRgb(color.value); });

        const hexInp = document.createElement('input');
        hexInp.type = 'text';
        hexInp.value = rgbToHex(rgb);
        hexInp.addEventListener('change', ()=>{
          try{ palette[idx] = hexToRgb(hexInp.value); color.value = rgbToHex(palette[idx]); }
          catch(e){ /*ignore*/ }
        });

        const del = document.createElement('button');
        del.className = 'remove';
        del.title = 'UsuÅ„ kolor';
        del.textContent = 'âœ•';
        del.addEventListener('click', ()=>{ palette.splice(idx,1); renderPaletteUI(); });

        wrap.appendChild(color); wrap.appendChild(hexInp); wrap.appendChild(del);
        paletteList.appendChild(wrap);
      });
    }

    function setDefaultPalette(){
      palette = DEFAULT_PALETTE_HEX.map(hexToRgb);
      renderPaletteUI();
    }

    // Nearest color mapping
    function nearestColor(rgb){
      let bestI = 0, bestD = Infinity;
      for (let i=0;i<palette.length;i++){
        const d = dist2(rgb, palette[i]);
        if (d < bestD){ bestD = d; bestI = i; }
      }
      return palette[bestI];
    }

    // Downscale to target (pixel grid), map to palette, then display upscaled
    function convertToPixelArt(){
      if (!originalImage) return;
      const targetW = Math.max(1, parseInt(wInput.value||'32'));
      const targetH = Math.max(1, parseInt(hInput.value||'32'));

      // Draw small (target) on an offscreen canvas
      const small = document.createElement('canvas');
      small.width = targetW; small.height = targetH;
      const sctx = small.getContext('2d');
      sctx.imageSmoothingEnabled = false;

      // Draw original into small keeping aspect by cover/contain logic
      // We'll fit by contain to avoid cropping
      const iw = originalImage.width, ih = originalImage.height;
      const ir = iw/ih, tr = targetW/targetH;
      let dw, dh, dx, dy;
      if (ir > tr){ // image is wider -> fit width
        dw = targetW; dh = Math.round(targetW/ir); dx = 0; dy = Math.floor((targetH - dh)/2);
      } else {
        dh = targetH; dw = Math.round(targetH*ir); dy = 0; dx = Math.floor((targetW - dw)/2);
      }
      sctx.fillStyle = 'black'; sctx.fillRect(0,0,targetW,targetH);
      sctx.drawImage(originalImage, dx, dy, dw, dh);

      const imgData = sctx.getImageData(0,0,targetW,targetH);
      const d = imgData.data;
      for (let i=0;i<d.length;i+=4){
        const mapped = nearestColor([d[i], d[i+1], d[i+2]]);
        d[i]=mapped[0]; d[i+1]=mapped[1]; d[i+2]=mapped[2]; d[i+3]=255;
      }
      sctx.putImageData(imgData,0,0);

      // Draw enlarged on output canvas
      const scale = Math.max(1, parseInt(exportScaleInput.value||'20'));
      outputCanvas.width = targetW*scale; outputCanvas.height = targetH*scale;
      outCtx.imageSmoothingEnabled = false;
      outCtx.clearRect(0,0,outputCanvas.width, outputCanvas.height);
      outCtx.drawImage(small, 0,0, outputCanvas.width, outputCanvas.height);
    }

    // Simple K-Means to extract palette
    function kmeansPalette(n=12){
      n = clamp(n, 2, 64);
      // Sample down original image to avoid huge arrays
      const samp = document.createElement('canvas');
      const maxS = 160; // speed
      const ir = originalImage.width / originalImage.height;
      let sw = maxS, sh = maxS;
      if (ir>1) sh = Math.round(maxS/ir); else sw = Math.round(maxS*ir);
      samp.width = sw; samp.height = sh;
      const sctx = samp.getContext('2d');
      sctx.imageSmoothingEnabled = true;
      sctx.drawImage(originalImage, 0,0, sw, sh);
      const {data} = sctx.getImageData(0,0,sw,sh);

      // Build points (skip transparent, though typical images are opaque)
      const pts = [];
      for (let i=0;i<data.length;i+=4){
        const a = data[i+3]; if (a<8) continue;
        pts.push([data[i], data[i+1], data[i+2]]);
      }
      if (pts.length===0) return;

      // Initialize centers by random samples
      const centers = [];
      const used = new Set();
      while (centers.length<n){
        const idx = Math.floor(Math.random()*pts.length);
        if (used.has(idx)) continue; used.add(idx);
        centers.push(pts[idx].slice());
      }

      const iters = 12;
      for (let it=0; it<iters; it++){
        const clusters = Array.from({length:n}, ()=>({sum:[0,0,0], count:0}));
        for (let p of pts){
          let bi=0, bd=Infinity; for (let i=0;i<n;i++){ const d=dist2(p, centers[i]); if (d<bd){bd=d; bi=i;} }
          clusters[bi].sum[0]+=p[0]; clusters[bi].sum[1]+=p[1]; clusters[bi].sum[2]+=p[2]; clusters[bi].count++;
        }
        for (let i=0;i<n;i++){
          if (clusters[i].count>0){
            centers[i][0] = Math.round(clusters[i].sum[0]/clusters[i].count);
            centers[i][1] = Math.round(clusters[i].sum[1]/clusters[i].count);
            centers[i][2] = Math.round(clusters[i].sum[2]/clusters[i].count);
          } else {
            // re-seed empty cluster
            const idx = Math.floor(Math.random()*pts.length);
            centers[i] = pts[idx].slice();
          }
        }
      }
      // Sort by luminance for nicer order
      centers.sort((a,b)=> (0.2126*a[0]+0.7152*a[1]+0.0722*a[2]) - (0.2126*b[0]+0.7152*b[1]+0.0722*b[2]) );
      palette = centers;
      renderPaletteUI();
    }

    // Events
    fileInput.addEventListener('change', (e)=>{
      const f = e.target.files?.[0]; if (!f) return;
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = ()=>{
        originalImage = img; aspect = img.width / img.height;
        drawImageOnCanvas(inputCanvas, img);
        if (lockAspect.checked){
          const w = parseInt(wInput.value||'32');
          hInput.value = Math.max(1, Math.round(w / aspect));
        }
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    // Drag & drop
    document.addEventListener('dragover', e=>{ e.preventDefault(); });
    document.addEventListener('drop', e=>{
      e.preventDefault();
      const f = e.dataTransfer.files?.[0]; if (!f) return;
      fileInput.files = e.dataTransfer.files; // for UX
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = ()=>{ originalImage = img; aspect = img.width/img.height; drawImageOnCanvas(inputCanvas, img); URL.revokeObjectURL(url); };
      img.src = url;
    });

    // Aspect lock behaviour
    wInput.addEventListener('input', ()=>{
      if (lockAspect.checked && aspect>0){ hInput.value = Math.max(1, Math.round(parseInt(wInput.value||'1')/aspect)); }
    });
    hInput.addEventListener('input', ()=>{
      if (lockAspect.checked && aspect>0){ wInput.value = Math.max(1, Math.round(parseInt(hInput.value||'1')*aspect)); }
    });

    convertBtn.addEventListener('click', convertToPixelArt);

    downloadBtn.addEventListener('click', ()=>{
      if (!originalImage) return;
      // Ensure latest conversion is drawn
      convertToPixelArt();
      const link = document.createElement('a');
      link.download = 'pixel-art.png';
      link.href = outputCanvas.toDataURL('image/png');
      link.click();
    });

    resetBtn.addEventListener('click', ()=>{
      originalImage = null; inputCanvas.width = inputCanvas.height = 256; inCtx.clearRect(0,0,256,256);
      outputCanvas.width = outputCanvas.height = 256; outCtx.clearRect(0,0,256,256);
      wInput.value = 32; hInput.value = 32; exportScaleInput.value = 20; aspect=1; setDefaultPalette();
    });

    addColorBtn.addEventListener('click', ()=>{ palette.push([255,255,255]); renderPaletteUI(); });
    clearPaletteBtn.addEventListener('click', ()=>{ palette = []; renderPaletteUI(); });
    loadDefaultPaletteBtn.addEventListener('click', setDefaultPalette);

    paletteFromImageBtn.addEventListener('click', ()=>{
      if (!originalImage) return;
      const n = parseInt(paletteSizeInput.value||'12');
      kmeansPalette(n);
    });

    // Init
    (function init(){
      setDefaultPalette();
      inputCanvas.width = inputCanvas.height = 256; inCtx.fillStyle = '#0a0f13'; inCtx.fillRect(0,0,256,256);
      outCtx.imageSmoothingEnabled = false; outputCanvas.width = outputCanvas.height = 256; outCtx.fillStyle = '#0a0f13'; outCtx.fillRect(0,0,256,256);
    })();
  </script>
</body>
</html>

